#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_json_1 = __importDefault(require("./../package.json"));
const fs_1 = require("fs");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const jsonpath_plus_1 = require("jsonpath-plus");
const zod_1 = require("zod");
const json_schema_to_zod_1 = require("json-schema-to-zod");
const node_assert_1 = __importDefault(require("node:assert"));
const node_path_1 = __importDefault(require("node:path"));
const commander_1 = require("commander");
const DISCLAIMER = `This file has been generated by ${package_json_1.default.name}, do not modify it`;
const TYPES = `
// ${DISCLAIMER}

export type Request = {
  pathParameters: Record<string, string | undefined>;
  queryParameters: Record<string, string | undefined>;
  body?: any;
};

export type Response = {
  statusCode: number;
  contentType: string;
  body: any;
};
`;
const hasField = (o, f) => {
    if (!o[f])
        false;
    return true;
};
const keys = (o) => {
    return Object.keys(o);
};
const statusCodeValidatorFrom = (statusCodeOAS) => {
    if (statusCodeOAS.includes('X')) {
        const min = parseInt(statusCodeOAS.replace(/X/g, '0'), 10);
        const max = parseInt(statusCodeOAS.replace(/X/g, '9'), 10);
        return `z.number().gte(${min}).lte(${max})`;
    }
    return `z.literal(${parseInt(statusCodeOAS)})`;
};
const parametersInSchema = zod_1.z.union([zod_1.z.literal('path'), zod_1.z.literal('query')]);
const parametersSchemaOAS = zod_1.z.array(zod_1.z.object({
    name: zod_1.z.string(),
    in: parametersInSchema,
    required: zod_1.z.boolean(),
    schema: zod_1.z.any(),
}));
const requestsSelectorSchemaOAS = zod_1.z.record(zod_1.z.string(), zod_1.z.record(zod_1.z.union([
    zod_1.z.literal('get'),
    zod_1.z.literal('post'),
    zod_1.z.literal('head'),
    zod_1.z.literal('options'),
    zod_1.z.literal('put'),
    zod_1.z.literal('delete'),
    zod_1.z.literal('patch'),
    zod_1.z.literal('trace'),
]), zod_1.z.object({
    operationId: zod_1.z.string().optional(),
})));
const requestBodySchemaOAS = zod_1.z.object({
    required: zod_1.z.boolean(),
    content: zod_1.z.record(zod_1.z.string(), zod_1.z.object({
        schema: zod_1.z.any(),
    })),
});
const responsesSchemaOAS = zod_1.z.record(zod_1.z.string(), zod_1.z.object({
    content: zod_1.z.record(zod_1.z.string(), zod_1.z.object({
        schema: zod_1.z.any(),
    })),
}));
const requestValidator = (oas, selector) => {
    const pathJ = `paths[${selector.path}].${selector.method.toLowerCase()}`;
    const requestJ = (0, jsonpath_plus_1.JSONPath)({
        path: pathJ,
        json: oas,
        flatten: true,
    });
    if (requestJ.length !== 1) {
        throw new Error(`found ${requestJ.length} element at ${pathJ} in OAS file, expected 1`);
    }
    const pathValidator = parametersValidatorIn(requestJ[0], 'path');
    const queryValidator = parametersValidatorIn(requestJ[0], 'query');
    const bodyValidator = requestBodyValidatorIn(requestJ[0]);
    let moduleS = `// ${DISCLAIMER}\n\n`;
    moduleS += `import { z } from "zod"\n\n`;
    moduleS += `export default z.object({\n`;
    moduleS += `  pathParameters: ${pathValidator},\n`;
    moduleS += `  queryParameters: ${queryValidator},\n`;
    moduleS += `  body: ${bodyValidator},\n`;
    moduleS += '})';
    return moduleS;
};
const parametersValidatorIn = (oas, where) => {
    if (!('parameters' in oas)) {
        return 'z.object({})';
    }
    const parametersP = parametersSchemaOAS.safeParse(oas['parameters']);
    if (!parametersP.success) {
        throw new Error('unexpected values in request parameters specification.\n' +
            JSON.stringify(parametersP.error.issues));
    }
    const parametersR = parametersP.data;
    let validator = `z.object({`;
    parametersR.forEach(p => {
        if (p.in !== where)
            return;
        if (p.required) {
            validator += `  "${p.name}": ${(0, json_schema_to_zod_1.parseSchema)(p.schema)},\n`;
        }
        else {
            validator += `  "${p.name}": ${(0, json_schema_to_zod_1.parseSchema)(p.schema)}.optional(),\n`;
        }
    });
    validator += '})';
    return validator;
};
const requestBodyValidatorIn = (oas) => {
    if (!('requestBody' in oas)) {
        return 'z.any()';
    }
    const requestBodyP = requestBodySchemaOAS.safeParse(oas['requestBody']);
    if (!requestBodyP.success) {
        throw new Error('unexpected values in request body specification.\n' +
            JSON.stringify(requestBodyP.error.issues));
    }
    const requestBodyR = requestBodyP.data;
    const contentTypes = Object.keys(requestBodyR.content);
    (0, node_assert_1.default)(contentTypes.length === 1);
    const contentType = contentTypes[0];
    (0, node_assert_1.default)(requestBodyR.content[contentType]);
    const requestBodyS = requestBodyR.content[contentType];
    (0, node_assert_1.default)(requestBodyS);
    return (0, json_schema_to_zod_1.parseSchema)(requestBodyS.schema);
};
const responsesValidator = (oas, selector) => {
    const pathJ = `paths[${selector.path}].${selector.method.toLowerCase()}.responses`;
    const responsesJ = (0, jsonpath_plus_1.JSONPath)({
        path: pathJ,
        json: oas,
        flatten: true,
    });
    if (responsesJ.length !== 1) {
        throw new Error(`found ${responsesJ.length} element at ${pathJ} in OAS file, expected 1`);
    }
    const responsesP = responsesSchemaOAS.safeParse(responsesJ[0]);
    if (!responsesP.success) {
        throw new Error('unexpected values in responses specification.\n' +
            JSON.stringify(responsesP.error.issues));
    }
    const responsesR = responsesP.data;
    let responseNames = [];
    let moduleS = `// ${DISCLAIMER}\n\n`;
    moduleS += `import { z } from "zod"\n\n`;
    Object.keys(responsesR).forEach(statusCode => {
        moduleS += `export const response${statusCode}Schema = z.object({\n`;
        moduleS += `  statusCode: ${statusCodeValidatorFrom(statusCode)},\n`;
        const contentTypes = Object.keys(responsesR[statusCode].content);
        (0, node_assert_1.default)(contentTypes.length === 1);
        const contentType = contentTypes[0];
        (0, node_assert_1.default)(responsesR[statusCode].content[contentType]);
        const responseBody = responsesR[statusCode].content[contentType];
        (0, node_assert_1.default)(responseBody);
        moduleS += `  contentType: z.literal('${contentType}'),\n`;
        moduleS += `  body: ${(0, json_schema_to_zod_1.parseSchema)(responsesR[statusCode].content[contentType].schema)},\n`;
        moduleS += '});\n';
        responseNames.push(`response${statusCode}Schema`);
    });
    if (responseNames.length > 1) {
        return (moduleS + `export default z.union([` + responseNames.join(', ') + ']);\n');
    }
    if (responseNames.length > 0) {
        return moduleS + `export default ${responseNames[0]};\n`;
    }
    return moduleS + `export default z.any();\n`;
};
const allRequestSelectors = (oas) => {
    if (!('paths' in oas)) {
        throw new Error('no requests found in OAS file');
    }
    const requestsP = requestsSelectorSchemaOAS.safeParse(oas.paths);
    if (!requestsP.success) {
        throw new Error('unexpected values in request specification.\n' +
            JSON.stringify(requestsP.error.issues));
    }
    const requestsR = requestsP.data;
    return keys(requestsR)
        .map(path => {
        return keys(requestsR[path]).map(method => {
            const requestR = requestsR[path][method];
            (0, node_assert_1.default)(requestR);
            if (hasField(requestR, 'operationId')) {
                return {
                    path,
                    method,
                    id: requestR.operationId || null,
                };
            }
            return {
                path,
                method,
                id: null,
            };
        });
    })
        .flat();
};
const normalizeName = (rs) => {
    const tokens = rs.path.slice(1).split('/');
    return (tokens
        .slice(0, 1)
        .concat(tokens.slice(1).map(t => {
        const matches = t.match(/^\{(.*)\}$/);
        if (matches) {
            return matches[1].toUpperCase();
        }
        return t.slice(0, 1).toUpperCase() + t.slice(1);
    }))
        .join('') +
        '.' +
        rs.method);
};
const fileExists = async (filePath) => {
    try {
        const file = await fs_1.promises.stat(filePath);
        return file.isFile();
    }
    catch (_a) {
        return false;
    }
};
const directoryExists = async (dirPath) => {
    try {
        const dir = await fs_1.promises.stat(dirPath);
        return dir.isDirectory();
    }
    catch (_a) {
        return false;
    }
};
const ensureOutputDirectory = async (dirPath) => {
    try {
        if (!(await directoryExists(dirPath))) {
            await fs_1.promises.mkdir(dirPath, {
                recursive: true,
                mode: 0o777,
            });
        }
        await fs_1.promises.access(dirPath, fs_1.promises.constants.W_OK);
    }
    catch (_) {
        throw new Error(`cannot create or access directory ${dirPath}, check your permissions`);
    }
};
const ensureInputFile = async (filePath) => {
    if (!(await fileExists(filePath))) {
        throw new Error(`file ${filePath}, do not exists`);
    }
    try {
        await fs_1.promises.access(filePath, fs_1.promises.constants.W_OK);
    }
    catch (_) {
        throw new Error(`cannot access file ${filePath}, check your permissions`);
    }
};
const writeFile = async (dirPath, fileName, content, overwrite) => {
    const filePath = node_path_1.default.join(dirPath, fileName);
    if ((await fileExists(filePath)) && !overwrite) {
        throw new Error(`file ${filePath} already exists, please use flag --overwrite if that's your intention`);
    }
    await fs_1.promises.writeFile(filePath, content, {
        encoding: 'utf8',
        mode: 0o600,
        flag: 'w+',
    });
};
const normalizePath = (pathIn) => {
    if (node_path_1.default.isAbsolute(pathIn)) {
        return pathIn;
    }
    return node_path_1.default.resolve(process.cwd(), pathIn);
};
const generate = async (oasPath, outPath, overwrite) => {
    await ensureInputFile(oasPath);
    await ensureOutputDirectory(outPath);
    const content = await fs_1.promises.readFile(oasPath, 'utf8');
    const oasF = JSON.parse(content.toString());
    const oasR = await new json_ref_resolver_1.Resolver().resolve(oasF);
    if (oasR.errors.length > 0) {
        throw new Error('unable to resolve references in OAS json.\n' +
            JSON.stringify(oasR.errors));
    }
    allRequestSelectors(oasR.result).forEach(async (requestSelector) => {
        const requestName = normalizeName(requestSelector);
        const requestValidatorModule = requestValidator(oasR.result, requestSelector);
        if (requestValidatorModule === null) {
            throw new Error(`failed to generate validators for request of ${requestName}`);
        }
        const responsesValidatorModule = responsesValidator(oasR.result, requestSelector);
        if (responsesValidatorModule === null) {
            throw new Error(`failed to generate validators for responses of ${requestName}`);
        }
        await writeFile(outPath, `${requestName}.requestValidator.ts`, requestValidatorModule, overwrite);
        await writeFile(outPath, `${requestName}.responsesValidator.ts`, responsesValidatorModule, overwrite);
    });
    await writeFile(outPath, 'types.ts', TYPES, overwrite);
};
const main = async (oasPath, outPath, overwrite) => {
    try {
        await generate(oasPath, outPath, overwrite);
        const relativeOutPath = node_path_1.default.relative(process.cwd(), outPath);
        console.log(`OK: everything was generated in ${relativeOutPath}\n`);
    }
    catch (e) {
        if (e instanceof Error) {
            console.error('ERROR: ' + e.message + '\n');
        }
        else {
            console.error(e);
        }
        process.exit(1);
    }
};
const program = new commander_1.Command();
program
    .name(package_json_1.default.name)
    .description(package_json_1.default.description)
    .version(package_json_1.default.version)
    .option('--overwrite', 'overwrite existing files if any')
    .option('-i, --input <path>', 'OAS specification file')
    .option('-o, --output <path>', 'output directory where to put generate files')
    .parse();
const options = program.opts();
if (!options.input || !options.output) {
    program.help();
}
main(normalizePath(options.input), normalizePath(options.output), options.overwrite || false);
//# sourceMappingURL=index.js.map